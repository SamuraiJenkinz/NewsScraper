---
phase: 06-delivery-critical-alerts
plan: 03
type: execute
wave: 2
depends_on: ["06-01", "06-02"]
files_modified:
  - app/services/emailer.py
autonomous: true

must_haves:
  truths:
    - "GraphEmailService.send_email_with_attachment() sends email with PDF attachment"
    - "Email attachment uses base64 encoding with 3MB limit check"
    - "send_report_email_with_pdf() generates PDF and attaches to email"
  artifacts:
    - path: "app/services/emailer.py"
      provides: "Enhanced email service with attachment support"
      exports: ["GraphEmailService"]
      contains: "send_email_with_attachment"
  key_links:
    - from: "app/services/emailer.py"
      to: "app/services/pdf_generator.py"
      via: "PDFGeneratorService for PDF creation"
      pattern: "PDFGeneratorService"
    - from: "app/services/emailer.py"
      to: "microsoft.graph"
      via: "fileAttachment in sendMail payload"
      pattern: "fileAttachment"
---

<objective>
Extend GraphEmailService with PDF attachment support for report delivery.

Purpose: DELV-07 requires PDF attachment in email. Microsoft Graph API supports base64-encoded inline attachments up to 4MB (3MB before encoding). This plan adds send_email_with_attachment() and enhances send_report_email() to include PDF.

Output: GraphEmailService with attachment support, integrated with PDFGeneratorService for complete report delivery workflow.
</objective>

<execution_context>
@C:\Users\taylo\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\taylo\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-delivery-critical-alerts/06-RESEARCH.md
@.planning/phases/06-delivery-critical-alerts/06-01-SUMMARY.md
@.planning/phases/06-delivery-critical-alerts/06-02-SUMMARY.md
@app/services/emailer.py
@app/services/pdf_generator.py
@app/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add send_email_with_attachment method</name>
  <files>app/services/emailer.py</files>
  <action>
Add new method to GraphEmailService for sending emails with file attachments.

1. Add base64 import at top of file:
   ```python
   import base64
   ```

2. Add new method after send_email():
   ```python
   async def send_email_with_attachment(
       self,
       to_addresses: list[str],
       subject: str,
       html_body: str,
       attachment_bytes: bytes,
       attachment_name: str,
       cc_addresses: list[str] | None = None,
       bcc_addresses: list[str] | None = None,
       content_type: str = "application/pdf",
       save_to_sent: bool = True,
   ) -> dict[str, Any]:
       """
       Send an HTML email with file attachment via Microsoft Graph.

       Uses inline base64 attachment (not upload session) for files under 3MB.
       Base64 encoding inflates size by ~33%, so 3MB file limit ensures
       we stay under Graph API's 4MB request limit.

       Args:
           to_addresses: List of TO recipient email addresses
           subject: Email subject line
           html_body: HTML content for email body
           attachment_bytes: Raw bytes of attachment file
           attachment_name: Filename for attachment (e.g., "report.pdf")
           cc_addresses: Optional list of CC recipients
           bcc_addresses: Optional list of BCC recipients
           content_type: MIME type of attachment (default: application/pdf)
           save_to_sent: Whether to save email to Sent folder

       Returns:
           dict with status, message, and attachment info
       """
       if not self.credential:
           logger.error("Graph credential not initialized - check Azure credentials")
           return {"status": "error", "message": "Microsoft Graph not configured"}

       if not to_addresses:
           return {"status": "error", "message": "No recipients specified"}

       # Check attachment size (3MB limit before encoding)
       max_size = 3 * 1024 * 1024
       if len(attachment_bytes) > max_size:
           return {
               "status": "error",
               "message": f"Attachment size {len(attachment_bytes):,} bytes exceeds {max_size:,} byte limit"
           }

       try:
           # Get access token
           token = self.credential.get_token("https://graph.microsoft.com/.default")

           # Base64 encode attachment
           attachment_base64 = base64.b64encode(attachment_bytes).decode('utf-8')

           # Build message payload with attachment
           message_payload = {
               "message": {
                   "subject": subject,
                   "body": {
                       "contentType": "HTML",
                       "content": html_body
                   },
                   "toRecipients": [
                       {"emailAddress": {"address": addr}} for addr in to_addresses
                   ],
                   "attachments": [
                       {
                           "@odata.type": "#microsoft.graph.fileAttachment",
                           "name": attachment_name,
                           "contentType": content_type,
                           "contentBytes": attachment_base64
                       }
                   ]
               },
               "saveToSentItems": save_to_sent
           }

           # Add CC recipients if provided
           if cc_addresses:
               message_payload["message"]["ccRecipients"] = [
                   {"emailAddress": {"address": addr}} for addr in cc_addresses
               ]

           # Add BCC recipients if provided
           if bcc_addresses:
               message_payload["message"]["bccRecipients"] = [
                   {"emailAddress": {"address": addr}} for addr in bcc_addresses
               ]

           # Send via Graph API
           logger.info(
               f"Sending email with attachment to {len(to_addresses)} recipients: {subject}",
               extra={"attachment_name": attachment_name, "attachment_size": len(attachment_bytes)}
           )

           async with httpx.AsyncClient() as client:
               response = await client.post(
                   f"https://graph.microsoft.com/v1.0/users/{self.sender_email}/sendMail",
                   headers={
                       "Authorization": f"Bearer {token.token}",
                       "Content-Type": "application/json"
                   },
                   json=message_payload,
                   timeout=60.0  # Longer timeout for attachment upload
               )

               if response.status_code == 202:
                   logger.info("Email with attachment sent successfully")
                   return {
                       "status": "sent",
                       "recipients": len(to_addresses),
                       "cc": len(cc_addresses) if cc_addresses else 0,
                       "bcc": len(bcc_addresses) if bcc_addresses else 0,
                       "attachment_name": attachment_name,
                       "attachment_size": len(attachment_bytes),
                   }
               else:
                   error_msg = f"Graph API error {response.status_code}: {response.text}"
                   logger.error(error_msg)
                   return {"status": "failed", "message": error_msg}

       except Exception as e:
           logger.error(f"Failed to send email with attachment: {e}")
           return {"status": "failed", "message": str(e)}
   ```
  </action>
  <verify>python -c "from app.services.emailer import GraphEmailService; hasattr(GraphEmailService, 'send_email_with_attachment') and print('OK')"</verify>
  <done>send_email_with_attachment method added to GraphEmailService</done>
</task>

<task type="auto">
  <name>Task 2: Add send_report_email_with_pdf method</name>
  <files>app/services/emailer.py</files>
  <action>
Add method that integrates PDF generation with email sending.

1. Add import at top:
   ```python
   from app.services.pdf_generator import PDFGeneratorService
   from app.schemas.delivery import EmailRecipients
   ```

2. Add new method after send_report_email():
   ```python
   async def send_report_email_with_pdf(
       self,
       category: str,
       html_content: str,
       report_date: str,
       recipients: EmailRecipients | None = None,
   ) -> dict[str, Any]:
       """
       Send a report email with PDF attachment for a specific category.

       Generates PDF from HTML content and attaches to email.
       Uses structured EmailRecipients if provided, otherwise falls back
       to get_email_recipients from settings.

       Args:
           category: Report category (Health, Dental, Group Life)
           html_content: Rendered HTML report content
           report_date: Report date string for subject line and filename
           recipients: Optional EmailRecipients (uses settings if None)

       Returns:
           dict with status, delivery details, and PDF info
       """
       settings = get_settings()

       # Get recipients
       if recipients is None:
           recipients = settings.get_email_recipients(category)

       if not recipients.to:
           logger.warning(f"No recipients configured for {category} reports")
           return {
               "status": "skipped",
               "message": f"No recipients configured for {category}",
           }

       try:
           # Generate PDF
           pdf_service = PDFGeneratorService()
           pdf_bytes, pdf_size = await pdf_service.generate_pdf(html_content)

           # Build subject and attachment name
           subject = f"[{settings.company_name}] {category} Intelligence Report - {report_date}"
           # Format: Health_Report_2026-02-04.pdf
           safe_date = report_date.replace("/", "-")
           attachment_name = f"{category.replace(' ', '_')}_Report_{safe_date}.pdf"

           # Send email with PDF attachment
           result = await self.send_email_with_attachment(
               to_addresses=recipients.to,
               subject=subject,
               html_body=html_content,
               attachment_bytes=pdf_bytes,
               attachment_name=attachment_name,
               cc_addresses=recipients.cc if recipients.cc else None,
               bcc_addresses=recipients.bcc if recipients.bcc else None,
           )

           # Add PDF info to result
           result["pdf_size"] = pdf_size
           result["pdf_name"] = attachment_name

           return result

       except ValueError as e:
           # PDF size exceeded limit
           logger.warning(f"PDF generation failed for {category}: {e}")
           # Fall back to email without attachment
           logger.info(f"Falling back to email without PDF attachment")
           return await self.send_email(
               to_addresses=recipients.to,
               subject=f"[{settings.company_name}] {category} Intelligence Report - {report_date}",
               html_body=html_content,
               cc_addresses=recipients.cc if recipients.cc else None,
               bcc_addresses=recipients.bcc if recipients.bcc else None,
           )

       except Exception as e:
           logger.error(f"Failed to send report with PDF: {e}")
           return {"status": "failed", "message": str(e)}
   ```
  </action>
  <verify>python -c "from app.services.emailer import GraphEmailService; hasattr(GraphEmailService, 'send_report_email_with_pdf') and print('OK')"</verify>
  <done>send_report_email_with_pdf method added with PDF generation integration</done>
</task>

</tasks>

<verification>
1. New methods exist:
   ```bash
   python -c "
   from app.services.emailer import GraphEmailService
   svc = GraphEmailService()
   print('send_email_with_attachment:', hasattr(svc, 'send_email_with_attachment'))
   print('send_report_email_with_pdf:', hasattr(svc, 'send_report_email_with_pdf'))
   "
   ```

2. Method signatures are correct:
   ```bash
   python -c "
   import inspect
   from app.services.emailer import GraphEmailService
   sig = inspect.signature(GraphEmailService.send_email_with_attachment)
   print('Parameters:', list(sig.parameters.keys()))
   "
   ```

3. Integration with PDFGeneratorService:
   ```bash
   python -c "
   from app.services.emailer import GraphEmailService
   import inspect
   source = inspect.getsource(GraphEmailService.send_report_email_with_pdf)
   print('Uses PDFGeneratorService:', 'PDFGeneratorService' in source)
   "
   ```
</verification>

<success_criteria>
- send_email_with_attachment() handles base64 encoding and 3MB limit
- send_report_email_with_pdf() generates PDF and attaches to email
- CC/BCC recipients properly included in email payload
- Graceful fallback to email without attachment if PDF exceeds size limit
- Status returns include attachment info (size, name)
</success_criteria>

<output>
After completion, create `.planning/phases/06-delivery-critical-alerts/06-03-SUMMARY.md`
</output>
