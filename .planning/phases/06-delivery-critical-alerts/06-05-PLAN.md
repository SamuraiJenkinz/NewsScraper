---
phase: 06-delivery-critical-alerts
plan: 05
type: execute
wave: 3
depends_on: ["06-01", "06-03", "06-04"]
files_modified:
  - app/routers/runs.py
  - scripts/migrate_005_delivery_tracking.py
autonomous: true

must_haves:
  truths:
    - "Run execution sends critical alerts immediately after classification"
    - "Run execution generates PDF and attaches to report email"
    - "Run completion updates delivery tracking fields in Run model"
    - "Database has delivery tracking columns via migration"
  artifacts:
    - path: "app/routers/runs.py"
      provides: "Enhanced run orchestration with delivery tracking"
      contains: "CriticalAlertService"
    - path: "scripts/migrate_005_delivery_tracking.py"
      provides: "Database migration for delivery columns"
      contains: "email_status"
  key_links:
    - from: "app/routers/runs.py"
      to: "app/services/alert_service.py"
      via: "check_and_send_alert()"
      pattern: "check_and_send_alert"
    - from: "app/routers/runs.py"
      to: "app/services/emailer.py"
      via: "send_report_email_with_pdf()"
      pattern: "send_report_email_with_pdf"
---

<objective>
Integrate enhanced delivery features into the run orchestration workflow.

Purpose: Connect all Phase 6 components - critical alerts, PDF generation, delivery tracking - into the existing run execution flow. This completes the delivery requirements by wiring services to the execution endpoint.

Output: Updated runs router that sends critical alerts after classification and report emails with PDF attachments, plus database migration for tracking columns.
</objective>

<execution_context>
@C:\Users\taylo\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\taylo\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-delivery-critical-alerts/06-01-SUMMARY.md
@.planning/phases/06-delivery-critical-alerts/06-03-SUMMARY.md
@.planning/phases/06-delivery-critical-alerts/06-04-SUMMARY.md
@app/routers/runs.py
@app/models/run.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create database migration script</name>
  <files>scripts/migrate_005_delivery_tracking.py</files>
  <action>
Create migration script to add delivery tracking columns to runs table:

```python
"""
Migration 005: Add delivery tracking columns to runs table.

Adds columns for tracking email delivery status, PDF generation,
and critical alert notifications (Phase 6).

Run with: python scripts/migrate_005_delivery_tracking.py
"""
import sqlite3
import sys
from pathlib import Path

# Database path
DB_PATH = Path(__file__).parent.parent / "data" / "brasilintel.db"


def get_existing_columns(cursor, table_name: str) -> set[str]:
    """Get set of existing column names for a table."""
    cursor.execute(f"PRAGMA table_info({table_name})")
    return {row[1] for row in cursor.fetchall()}


def migrate():
    """Run the migration."""
    if not DB_PATH.exists():
        print(f"[ERROR] Database not found at {DB_PATH}")
        sys.exit(1)

    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()

    try:
        existing = get_existing_columns(cursor, "runs")
        print(f"[INFO] Existing columns in runs: {len(existing)}")

        # Columns to add with their definitions
        new_columns = [
            ("email_status", "VARCHAR(20)"),
            ("email_sent_at", "DATETIME"),
            ("email_recipients_count", "INTEGER DEFAULT 0"),
            ("email_error_message", "TEXT"),
            ("pdf_generated", "BOOLEAN DEFAULT 0"),
            ("pdf_size_bytes", "INTEGER"),
            ("critical_alert_sent", "BOOLEAN DEFAULT 0"),
            ("critical_alert_sent_at", "DATETIME"),
            ("critical_insurers_count", "INTEGER DEFAULT 0"),
        ]

        added = 0
        skipped = 0

        for col_name, col_def in new_columns:
            if col_name in existing:
                print(f"[SKIP] Column '{col_name}' already exists")
                skipped += 1
            else:
                print(f"[ADD] Adding column '{col_name}'...")
                cursor.execute(f"ALTER TABLE runs ADD COLUMN {col_name} {col_def}")
                added += 1

        conn.commit()

        print()
        print(f"[DONE] Migration complete")
        print(f"       Added: {added} columns")
        print(f"       Skipped: {skipped} columns (already exist)")

        # Verify
        final_cols = get_existing_columns(cursor, "runs")
        print(f"       Total columns in runs: {len(final_cols)}")

    except Exception as e:
        conn.rollback()
        print(f"[ERROR] Migration failed: {e}")
        sys.exit(1)

    finally:
        conn.close()


if __name__ == "__main__":
    print("=" * 60)
    print("Migration 005: Delivery Tracking Columns")
    print("=" * 60)
    migrate()
```

Run migration to add columns to existing database.
  </action>
  <verify>python scripts/migrate_005_delivery_tracking.py</verify>
  <done>Migration script created and executed, delivery tracking columns added to runs table</done>
</task>

<task type="auto">
  <name>Task 2: Update run orchestration with delivery integration</name>
  <files>app/routers/runs.py</files>
  <action>
Update runs.py to integrate critical alerts and PDF email delivery:

1. Add imports at top:
   ```python
   from app.services.alert_service import CriticalAlertService
   from app.schemas.delivery import DeliveryStatus
   ```

2. Update _generate_and_send_report() to use professional reports with PDF:
   ```python
   async def _generate_and_send_report(
       category: str,
       run_id: int,
       db: Session,
       send_email: bool,
   ) -> dict[str, Any]:
       """Generate professional HTML report with PDF and optionally send via email."""
       logger.info("Generating professional HTML report...")
       report_service = ReportService()

       # Generate professional report with archival
       html_report, archive_path = report_service.generate_professional_report_from_db(
           category=category,
           run_id=run_id,
           db_session=db,
           use_ai_summary=True,
           archive_report=True,
       )

       result = {
           "email_sent": False,
           "email_status": DeliveryStatus.SKIPPED if not send_email else DeliveryStatus.PENDING,
           "pdf_size": 0,
           "archive_path": str(archive_path) if archive_path else None,
       }

       if send_email:
           logger.info("Sending email report with PDF attachment...")
           email_service = GraphEmailService()
           report_date = datetime.now().strftime("%Y-%m-%d")

           email_result = await email_service.send_report_email_with_pdf(
               category=category,
               html_content=html_report,
               report_date=report_date,
           )

           result["email_sent"] = email_result.get("status") in ["ok", "sent"]
           result["email_status"] = email_result.get("status", "failed")
           result["pdf_size"] = email_result.get("pdf_size", 0)
           result["recipients"] = email_result.get("recipients", 0)

           if result["email_sent"]:
               logger.info(f"Email sent successfully with PDF ({result['pdf_size']} bytes)")
           else:
               logger.warning(f"Email not sent: {email_result.get('message')}")

       return result
   ```

3. Add critical alert check in _execute_single_insurer_run() after classification loop:
   ```python
   # After classification loop, before report generation:
   # Check for critical alerts and send immediately
   logger.info("Checking for critical alerts...")
   alert_service = CriticalAlertService()
   alert_result = await alert_service.check_and_send_alert(
       category=request.category,
       run_id=run.id,
       db=db,
   )
   if alert_result.get("critical_count", 0) > 0:
       logger.info(f"Critical alert sent for {alert_result['critical_count']} insurer(s)")
   ```

4. Add same critical alert check in _execute_category_run() after classification.

5. Update run completion to track delivery:
   ```python
   # Before final run.status = RunStatus.COMPLETED:
   # Update delivery tracking
   run.email_status = delivery_result.get("email_status")
   run.email_sent_at = datetime.utcnow() if delivery_result.get("email_sent") else None
   run.email_recipients_count = delivery_result.get("recipients", 0)
   run.pdf_generated = delivery_result.get("pdf_size", 0) > 0
   run.pdf_size_bytes = delivery_result.get("pdf_size", 0)
   ```

6. Update ExecuteResponse model to include delivery info:
   ```python
   class ExecuteResponse(BaseModel):
       """Response model for execute endpoint."""
       run_id: int
       status: str
       insurers_processed: int
       items_found: int
       email_sent: bool
       email_status: str = "pending"  # NEW
       pdf_generated: bool = False  # NEW
       pdf_size_bytes: int = 0  # NEW
       critical_alerts_sent: int = 0  # NEW
       message: str
       errors: list[str] = Field(default_factory=list)
   ```
  </action>
  <verify>python -c "from app.routers.runs import router; print('OK')"</verify>
  <done>Run orchestration updated with critical alerts and PDF email delivery</done>
</task>

<task type="auto">
  <name>Task 3: Add delivery status endpoint</name>
  <files>app/routers/runs.py</files>
  <action>
Add endpoint to check delivery status for a run:

```python
@router.get("/{run_id}/delivery", response_model=dict)
def get_run_delivery_status(
    run_id: int,
    db: Session = Depends(get_db),
) -> dict:
    """
    Get delivery status for a specific run.

    Returns email delivery details, PDF generation status,
    and critical alert information.
    """
    run = db.query(Run).filter(Run.id == run_id).first()

    if not run:
        raise HTTPException(status_code=404, detail=f"Run {run_id} not found")

    return {
        "run_id": run.id,
        "category": run.category,
        "status": run.status,
        "email": {
            "status": run.email_status,
            "sent_at": run.email_sent_at.isoformat() if run.email_sent_at else None,
            "recipients_count": run.email_recipients_count or 0,
            "error_message": run.email_error_message,
        },
        "pdf": {
            "generated": run.pdf_generated or False,
            "size_bytes": run.pdf_size_bytes or 0,
        },
        "critical_alert": {
            "sent": run.critical_alert_sent or False,
            "sent_at": run.critical_alert_sent_at.isoformat() if run.critical_alert_sent_at else None,
            "insurers_count": run.critical_insurers_count or 0,
        }
    }
```

This endpoint allows checking delivery status after run completion.
  </action>
  <verify>python -c "from app.routers.runs import get_run_delivery_status; print('OK')"</verify>
  <done>Delivery status endpoint added at GET /api/runs/{run_id}/delivery</done>
</task>

</tasks>

<verification>
1. Migration completed:
   ```bash
   python -c "
   import sqlite3
   conn = sqlite3.connect('data/brasilintel.db')
   cursor = conn.cursor()
   cursor.execute('PRAGMA table_info(runs)')
   cols = [row[1] for row in cursor.fetchall()]
   print('Has email_status:', 'email_status' in cols)
   print('Has pdf_generated:', 'pdf_generated' in cols)
   print('Has critical_alert_sent:', 'critical_alert_sent' in cols)
   conn.close()
   "
   ```

2. Router imports work:
   ```bash
   python -c "from app.routers.runs import router; print('OK')"
   ```

3. New endpoint exists:
   ```bash
   python -c "
   from app.routers.runs import router
   paths = [r.path for r in router.routes]
   print('Has delivery endpoint:', '/{run_id}/delivery' in paths)
   "
   ```

4. Integration works (basic smoke test):
   ```bash
   python -c "
   from app.services.alert_service import CriticalAlertService
   from app.services.emailer import GraphEmailService
   print('CriticalAlertService:', CriticalAlertService)
   print('GraphEmailService:', GraphEmailService)
   "
   ```
</verification>

<success_criteria>
- Database migration adds delivery tracking columns to runs table
- Run execution calls CriticalAlertService.check_and_send_alert() after classification
- Run execution uses send_report_email_with_pdf() for report delivery
- Run completion updates email_status, pdf_generated, critical_alert_sent fields
- GET /api/runs/{run_id}/delivery endpoint returns delivery status details
- ExecuteResponse includes delivery info (email_status, pdf_generated, critical_alerts_sent)
</success_criteria>

<output>
After completion, create `.planning/phases/06-delivery-critical-alerts/06-05-SUMMARY.md`
</output>
