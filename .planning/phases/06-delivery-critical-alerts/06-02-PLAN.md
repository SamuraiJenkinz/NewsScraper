---
phase: 06-delivery-critical-alerts
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - app/services/pdf_generator.py
  - requirements.txt
autonomous: true

must_haves:
  truths:
    - "PDFGeneratorService converts HTML to PDF bytes using WeasyPrint"
    - "PDF generation runs in thread pool to avoid blocking event loop"
    - "Generated PDF is under 3MB limit for email attachment"
  artifacts:
    - path: "app/services/pdf_generator.py"
      provides: "Async PDF generation service"
      exports: ["PDFGeneratorService"]
      min_lines: 60
    - path: "requirements.txt"
      provides: "WeasyPrint dependency"
      contains: "weasyprint"
  key_links:
    - from: "app/services/pdf_generator.py"
      to: "weasyprint"
      via: "HTML().write_pdf()"
      pattern: "HTML.*write_pdf"
---

<objective>
Create PDF generation service using WeasyPrint for converting HTML reports to PDF format.

Purpose: DELV-06 requires PDF version of reports. WeasyPrint handles CSS print media queries and avoids browser dependencies. Async wrapper prevents blocking the FastAPI event loop during CPU-intensive PDF rendering.

Output: PDFGeneratorService with async generate_pdf() method that returns PDF bytes suitable for email attachment.
</objective>

<execution_context>
@C:\Users\taylo\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\taylo\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-delivery-critical-alerts/06-RESEARCH.md
@app/services/reporter.py
@app/templates/report_professional.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add WeasyPrint dependency</name>
  <files>requirements.txt</files>
  <action>
Add WeasyPrint to requirements.txt:

```
weasyprint>=63.1
```

WeasyPrint 63.1+ is the 2026-recommended version for static HTML-to-PDF conversion. It automatically installs required dependencies (Pillow, etc.).

Note: WeasyPrint on Windows requires GTK3 runtime. Document this in comments or README if needed, but the pip install handles Python dependencies.
  </action>
  <verify>grep -i weasyprint requirements.txt</verify>
  <done>weasyprint>=63.1 added to requirements.txt</done>
</task>

<task type="auto">
  <name>Task 2: Create PDFGeneratorService</name>
  <files>app/services/pdf_generator.py</files>
  <action>
Create PDF generation service with async support:

```python
"""
PDF generation service using WeasyPrint.

Converts HTML reports to PDF format for email attachments.
Uses asyncio.to_thread() to avoid blocking the event loop.
"""
import asyncio
from pathlib import Path
from typing import Optional, Tuple

from weasyprint import HTML, CSS
from weasyprint.text.fonts import FontConfiguration
import structlog

logger = structlog.get_logger()


class PDFGeneratorService:
    """
    Service for generating PDFs from HTML reports.

    Uses WeasyPrint for static HTML rendering with CSS print
    media support. All PDF generation runs in a thread pool
    to avoid blocking the async event loop.
    """

    # Maximum PDF size for email attachment (3MB - base64 inflates by ~33%)
    MAX_PDF_SIZE = 3 * 1024 * 1024

    def __init__(self):
        """Initialize with font configuration and print CSS."""
        self.font_config = FontConfiguration()

        # Print-optimized CSS
        self.print_css = CSS(string='''
            @page {
                size: A4;
                margin: 1.5cm;
            }
            @media print {
                .no-print { display: none; }
                a { color: #0066cc; text-decoration: underline; }
                body { font-size: 10pt; }
                h1 { page-break-after: avoid; }
                h2, h3 { page-break-after: avoid; }
                table { page-break-inside: avoid; }
                .insurer-card { page-break-inside: avoid; }
            }
        ''', font_config=self.font_config)

    async def generate_pdf(
        self,
        html_content: str,
        output_path: Optional[Path] = None
    ) -> Tuple[bytes, int]:
        """
        Generate PDF from HTML content asynchronously.

        Runs the CPU-intensive PDF generation in a thread pool
        to avoid blocking the event loop.

        Args:
            html_content: HTML string to convert
            output_path: Optional path to save PDF file

        Returns:
            Tuple of (pdf_bytes, file_size_bytes)

        Raises:
            ValueError: If PDF exceeds size limit or generation fails
        """
        logger.info("pdf_generation_started", html_size=len(html_content))

        try:
            # Run CPU-intensive operation in thread pool
            pdf_bytes = await asyncio.to_thread(
                self._generate_pdf_sync,
                html_content
            )

            file_size = len(pdf_bytes)

            # Check size limit for email attachment
            if file_size > self.MAX_PDF_SIZE:
                raise ValueError(
                    f"PDF size {file_size:,} bytes exceeds "
                    f"{self.MAX_PDF_SIZE:,} byte limit for email attachment"
                )

            # Optionally save to file
            if output_path:
                output_path.parent.mkdir(parents=True, exist_ok=True)
                await asyncio.to_thread(output_path.write_bytes, pdf_bytes)
                logger.info("pdf_saved", path=str(output_path), size_kb=file_size // 1024)

            logger.info("pdf_generation_complete", size_kb=file_size // 1024)
            return pdf_bytes, file_size

        except Exception as e:
            logger.error("pdf_generation_failed", error=str(e))
            raise

    def _generate_pdf_sync(self, html_content: str) -> bytes:
        """
        Synchronous PDF generation (runs in thread pool).

        Args:
            html_content: HTML string to convert

        Returns:
            PDF bytes
        """
        return HTML(string=html_content).write_pdf(
            stylesheets=[self.print_css],
            font_config=self.font_config
        )

    async def generate_pdf_from_file(
        self,
        html_path: Path,
        output_path: Optional[Path] = None
    ) -> Tuple[bytes, int]:
        """
        Generate PDF from HTML file.

        Args:
            html_path: Path to HTML file
            output_path: Optional path to save PDF file

        Returns:
            Tuple of (pdf_bytes, file_size_bytes)
        """
        html_content = await asyncio.to_thread(
            html_path.read_text,
            encoding='utf-8'
        )
        return await self.generate_pdf(html_content, output_path)
```

Key implementation details:
- asyncio.to_thread() for non-blocking PDF generation
- FontConfiguration for proper Windows font rendering
- Print-optimized CSS with page breaks
- 3MB size limit check (base64 encoding adds ~33%)
- Structured logging with structlog
  </action>
  <verify>python -c "from app.services.pdf_generator import PDFGeneratorService; print('OK')"</verify>
  <done>PDFGeneratorService created with async generate_pdf() method</done>
</task>

<task type="auto">
  <name>Task 3: Test PDF generation with sample HTML</name>
  <files>tests/test_pdf_generator.py</files>
  <action>
Create basic test to verify PDF generation works:

```python
"""Tests for PDF generation service."""
import pytest
from pathlib import Path

from app.services.pdf_generator import PDFGeneratorService


class TestPDFGeneratorService:
    """Test suite for PDFGeneratorService."""

    @pytest.fixture
    def pdf_service(self):
        """Create PDF service instance."""
        return PDFGeneratorService()

    @pytest.fixture
    def sample_html(self):
        """Sample HTML for testing."""
        return '''
        <!DOCTYPE html>
        <html>
        <head><title>Test Report</title></head>
        <body>
            <h1>BrasilIntel Test Report</h1>
            <p>This is a test paragraph.</p>
            <table>
                <tr><th>Insurer</th><th>Status</th></tr>
                <tr><td>Test Corp</td><td>Stable</td></tr>
            </table>
        </body>
        </html>
        '''

    @pytest.mark.asyncio
    async def test_generate_pdf_returns_bytes(self, pdf_service, sample_html):
        """Test that PDF generation returns bytes."""
        pdf_bytes, size = await pdf_service.generate_pdf(sample_html)

        assert isinstance(pdf_bytes, bytes)
        assert size > 0
        # PDF magic bytes
        assert pdf_bytes[:4] == b'%PDF'

    @pytest.mark.asyncio
    async def test_generate_pdf_size_reasonable(self, pdf_service, sample_html):
        """Test that generated PDF is under size limit."""
        pdf_bytes, size = await pdf_service.generate_pdf(sample_html)

        assert size < PDFGeneratorService.MAX_PDF_SIZE
        # Simple HTML should be well under 1MB
        assert size < 1 * 1024 * 1024

    @pytest.mark.asyncio
    async def test_generate_pdf_with_output_path(self, pdf_service, sample_html, tmp_path):
        """Test saving PDF to file."""
        output_path = tmp_path / "test_report.pdf"

        pdf_bytes, size = await pdf_service.generate_pdf(sample_html, output_path)

        assert output_path.exists()
        assert output_path.stat().st_size == size
        assert output_path.read_bytes()[:4] == b'%PDF'
```

Run with: pytest tests/test_pdf_generator.py -v
  </action>
  <verify>pytest tests/test_pdf_generator.py -v --tb=short 2>/dev/null || python -m pytest tests/test_pdf_generator.py -v --tb=short</verify>
  <done>PDF generation tests pass, verifying WeasyPrint integration works</done>
</task>

</tasks>

<verification>
1. WeasyPrint installed:
   ```bash
   pip install -r requirements.txt
   python -c "import weasyprint; print(weasyprint.__version__)"
   ```

2. Service imports correctly:
   ```bash
   python -c "from app.services.pdf_generator import PDFGeneratorService; print('OK')"
   ```

3. PDF generation works:
   ```bash
   python -c "
   import asyncio
   from app.services.pdf_generator import PDFGeneratorService

   async def test():
       svc = PDFGeneratorService()
       html = '<html><body><h1>Test</h1></body></html>'
       pdf, size = await svc.generate_pdf(html)
       print(f'Generated {size} bytes, starts with: {pdf[:4]}')

   asyncio.run(test())
   "
   ```
</verification>

<success_criteria>
- weasyprint>=63.1 in requirements.txt
- PDFGeneratorService exists with async generate_pdf() method
- PDF generation returns valid PDF bytes (starts with %PDF)
- PDF size is under 3MB limit
- Tests pass for basic PDF generation
</success_criteria>

<output>
After completion, create `.planning/phases/06-delivery-critical-alerts/06-02-SUMMARY.md`
</output>
