---
phase: 06-delivery-critical-alerts
plan: 04
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - app/services/alert_service.py
  - app/templates/alert_critical.html
autonomous: true

must_haves:
  truths:
    - "CriticalAlertService sends immediate email when Critical status detected"
    - "Critical alerts have [CRITICAL ALERT] prefix in subject line"
    - "Alert email shows critical insurers with their news headlines"
    - "Critical alerts are separate from daily digest emails"
  artifacts:
    - path: "app/services/alert_service.py"
      provides: "Critical alert detection and notification service"
      exports: ["CriticalAlertService"]
      min_lines: 80
    - path: "app/templates/alert_critical.html"
      provides: "Jinja2 template for critical alert emails"
      contains: "CRITICAL"
  key_links:
    - from: "app/services/alert_service.py"
      to: "app/services/emailer.py"
      via: "GraphEmailService.send_email()"
      pattern: "send_email"
    - from: "app/services/alert_service.py"
      to: "app/templates/alert_critical.html"
      via: "Jinja2 template rendering"
      pattern: "get_template.*alert_critical"
---

<objective>
Create critical alert service for immediate notification when Critical status is detected.

Purpose: DELV-04 and DELV-05 require immediate separate alerts for Critical status, not bundled with daily digest. This enables faster response to urgent situations affecting Marsh Brasil clients.

Output: CriticalAlertService that detects Critical insurers from a run and sends focused alert email with [CRITICAL ALERT] subject prefix.
</objective>

<execution_context>
@C:\Users\taylo\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\taylo\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-delivery-critical-alerts/06-RESEARCH.md
@.planning/phases/06-delivery-critical-alerts/06-01-SUMMARY.md
@app/services/emailer.py
@app/models/insurer.py
@app/models/news_item.py
@app/models/run.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create critical alert email template</name>
  <files>app/templates/alert_critical.html</files>
  <action>
Create Jinja2 template for critical alert emails. Keep it focused and urgent:

```html
<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alerta Critico - {{ category }}</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
        }
        .alert-header {
            background-color: #d32f2f;
            color: white;
            padding: 15px 20px;
            border-radius: 4px;
            margin-bottom: 20px;
        }
        .alert-header h1 {
            margin: 0;
            font-size: 20px;
        }
        .alert-header p {
            margin: 5px 0 0 0;
            font-size: 14px;
            opacity: 0.9;
        }
        .insurer-card {
            border-left: 4px solid #d32f2f;
            padding: 12px 16px;
            margin: 16px 0;
            background-color: #fff5f5;
        }
        .insurer-name {
            font-size: 16px;
            font-weight: bold;
            color: #c62828;
            margin: 0 0 8px 0;
        }
        .insurer-code {
            font-size: 12px;
            color: #666;
            margin-bottom: 10px;
        }
        .news-list {
            margin: 0;
            padding-left: 20px;
        }
        .news-list li {
            margin-bottom: 8px;
        }
        .news-title {
            font-weight: 500;
        }
        .news-source {
            font-size: 12px;
            color: #666;
        }
        .footer {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
            font-size: 12px;
            color: #666;
        }
        .action-needed {
            background-color: #fff3e0;
            border: 1px solid #ffb74d;
            padding: 12px;
            border-radius: 4px;
            margin: 20px 0;
        }
        .action-needed strong {
            color: #e65100;
        }
    </style>
</head>
<body>
    <div class="alert-header">
        <h1>⚠️ ALERTA CRITICO: {{ category }}</h1>
        <p>{{ critical_count }} seguradora(s) identificada(s) em status critico</p>
    </div>

    <div class="action-needed">
        <strong>Acao Necessaria:</strong> As seguintes seguradoras apresentam indicadores criticos
        que podem impactar clientes da {{ company_name }}. Recomenda-se avaliacao imediata.
    </div>

    {% for insurer in critical_insurers %}
    <div class="insurer-card">
        <h3 class="insurer-name">{{ insurer.name }}</h3>
        <div class="insurer-code">ANS: {{ insurer.ans_code }} | CNPJ: {{ insurer.cnpj or 'N/A' }}</div>

        {% if insurer.critical_news %}
        <ul class="news-list">
            {% for news in insurer.critical_news %}
            <li>
                <span class="news-title">{{ news.title }}</span>
                <br>
                <span class="news-source">Fonte: {{ news.source_name }} | {{ news.published_at.strftime('%d/%m/%Y') if news.published_at else 'Data N/A' }}</span>
            </li>
            {% endfor %}
        </ul>
        {% endif %}
    </div>
    {% endfor %}

    <div class="footer">
        <p>
            Este e um alerta automatico do sistema BrasilIntel.<br>
            O relatorio completo sera enviado no proximo digest diario.
        </p>
        <p>
            <strong>{{ company_name }}</strong> | Intelligence Report<br>
            Gerado em: {{ timestamp }}
        </p>
    </div>
</body>
</html>
```

Template variables:
- category: Report category (Health, Dental, Group Life)
- critical_count: Number of critical insurers
- company_name: From settings
- critical_insurers: List of Insurer objects with critical_news attribute
- timestamp: Generation timestamp
  </action>
  <verify>test -f app/templates/alert_critical.html && grep -q "ALERTA CRITICO" app/templates/alert_critical.html && echo "OK"</verify>
  <done>Critical alert email template created with Portuguese content</done>
</task>

<task type="auto">
  <name>Task 2: Create CriticalAlertService</name>
  <files>app/services/alert_service.py</files>
  <action>
Create service for detecting and sending critical alerts:

```python
"""
Critical alert service for immediate notification of Critical status.

Sends separate alert emails when Critical status is detected during
classification, separate from the daily digest reports.
"""
from datetime import datetime
from pathlib import Path
from typing import Any

from jinja2 import Environment, FileSystemLoader, select_autoescape
from sqlalchemy.orm import Session
import structlog

from app.config import get_settings
from app.models.insurer import Insurer
from app.models.news_item import NewsItem
from app.models.run import Run
from app.services.emailer import GraphEmailService

logger = structlog.get_logger()


class CriticalAlertService:
    """
    Service for detecting and sending critical alerts.

    Sends immediate email notifications when Critical status is detected,
    separate from daily digest reports.
    """

    def __init__(self, email_service: GraphEmailService | None = None):
        """
        Initialize alert service.

        Args:
            email_service: Optional GraphEmailService instance (creates new if None)
        """
        self.settings = get_settings()
        self.email_service = email_service or GraphEmailService()

        # Setup Jinja2 for alert templates
        template_dir = Path(__file__).parent.parent / "templates"
        self.env = Environment(
            loader=FileSystemLoader(str(template_dir)),
            autoescape=select_autoescape(['html', 'xml'])
        )

    def find_critical_insurers(
        self,
        category: str,
        run_id: int,
        db: Session
    ) -> list[Insurer]:
        """
        Find insurers with Critical status in a run.

        Args:
            category: Insurer category
            run_id: Run ID to check
            db: Database session

        Returns:
            List of Insurer objects with critical_news attribute populated
        """
        # Find unique insurers with Critical news in this run
        critical_insurers = (
            db.query(Insurer)
            .filter(Insurer.category == category)
            .join(NewsItem, NewsItem.insurer_id == Insurer.id)
            .filter(
                NewsItem.run_id == run_id,
                NewsItem.status == "Critical"
            )
            .distinct()
            .all()
        )

        # Load critical news for each insurer
        for insurer in critical_insurers:
            insurer.critical_news = (
                db.query(NewsItem)
                .filter(
                    NewsItem.insurer_id == insurer.id,
                    NewsItem.run_id == run_id,
                    NewsItem.status == "Critical"
                )
                .all()
            )

        logger.info(
            "critical_insurers_found",
            category=category,
            run_id=run_id,
            count=len(critical_insurers)
        )

        return critical_insurers

    async def check_and_send_alert(
        self,
        category: str,
        run_id: int,
        db: Session
    ) -> dict[str, Any]:
        """
        Check for critical status and send immediate alert if found.

        This should be called during the classification phase, separate
        from the daily digest report workflow.

        Args:
            category: Insurer category
            run_id: Run ID to check
            db: Database session

        Returns:
            dict with status and alert details
        """
        # Find critical insurers
        critical_insurers = self.find_critical_insurers(category, run_id, db)

        if not critical_insurers:
            logger.info("no_critical_alerts", category=category, run_id=run_id)
            return {
                "status": "none",
                "message": "No critical alerts to send",
                "critical_count": 0
            }

        # Get recipients (same as daily digest for now)
        recipients = self.settings.get_email_recipients(category)

        if not recipients.to:
            logger.warning(
                "critical_alert_no_recipients",
                category=category,
                critical_count=len(critical_insurers)
            )
            return {
                "status": "skipped",
                "message": f"No recipients configured for {category}",
                "critical_count": len(critical_insurers)
            }

        # Build alert email
        alert_html = self._build_alert_html(
            category=category,
            critical_insurers=critical_insurers
        )

        # Subject with CRITICAL ALERT prefix
        subject = (
            f"[CRITICAL ALERT] {category} Insurer Status - "
            f"{len(critical_insurers)} Critical Item(s) Detected"
        )

        # Send alert email (no PDF - speed is priority)
        result = await self.email_service.send_email(
            to_addresses=recipients.to,
            subject=subject,
            html_body=alert_html,
            cc_addresses=recipients.cc if recipients.cc else None,
            bcc_addresses=recipients.bcc if recipients.bcc else None,
            save_to_sent=True,
        )

        # Update run with critical alert tracking
        run = db.query(Run).filter(Run.id == run_id).first()
        if run:
            run.critical_alert_sent = result.get("status") in ["ok", "sent"]
            run.critical_alert_sent_at = datetime.utcnow()
            run.critical_insurers_count = len(critical_insurers)
            db.commit()

        logger.info(
            "critical_alert_sent",
            category=category,
            run_id=run_id,
            critical_count=len(critical_insurers),
            status=result.get("status")
        )

        return {
            "status": result.get("status"),
            "critical_count": len(critical_insurers),
            "critical_insurers": [i.name for i in critical_insurers],
            "recipients": len(recipients.to),
            "message": result.get("message")
        }

    def _build_alert_html(
        self,
        category: str,
        critical_insurers: list[Insurer]
    ) -> str:
        """
        Build HTML for critical alert email.

        Args:
            category: Report category
            critical_insurers: List of Insurer objects with critical_news

        Returns:
            Rendered HTML string
        """
        template = self.env.get_template("alert_critical.html")

        return template.render(
            category=category,
            critical_count=len(critical_insurers),
            critical_insurers=critical_insurers,
            company_name=self.settings.company_name,
            timestamp=datetime.now().strftime("%d/%m/%Y as %H:%M")
        )
```

Key features:
- find_critical_insurers() queries for Critical status
- check_and_send_alert() is the main entry point
- Updates Run model with critical alert tracking
- Uses same recipients as daily digest (configurable later if needed)
- [CRITICAL ALERT] prefix distinguishes from digest
  </action>
  <verify>python -c "from app.services.alert_service import CriticalAlertService; print('OK')"</verify>
  <done>CriticalAlertService created with critical detection and alert sending</done>
</task>

</tasks>

<verification>
1. Template exists and has correct content:
   ```bash
   test -f app/templates/alert_critical.html && echo "Template exists"
   grep "ALERTA CRITICO" app/templates/alert_critical.html && echo "Has Portuguese header"
   ```

2. Service imports correctly:
   ```bash
   python -c "from app.services.alert_service import CriticalAlertService; print('OK')"
   ```

3. Service has required methods:
   ```bash
   python -c "
   from app.services.alert_service import CriticalAlertService
   svc = CriticalAlertService()
   print('find_critical_insurers:', hasattr(svc, 'find_critical_insurers'))
   print('check_and_send_alert:', hasattr(svc, 'check_and_send_alert'))
   "
   ```

4. Template renders without errors:
   ```bash
   python -c "
   from jinja2 import Environment, FileSystemLoader
   from pathlib import Path
   from datetime import datetime

   template_dir = Path('app/templates')
   env = Environment(loader=FileSystemLoader(str(template_dir)))
   template = env.get_template('alert_critical.html')

   # Mock data
   class MockNews:
       title = 'Test news'
       source_name = 'Test Source'
       published_at = datetime.now()

   class MockInsurer:
       name = 'Test Insurer'
       ans_code = '123456'
       cnpj = '12.345.678/0001-90'
       critical_news = [MockNews()]

   html = template.render(
       category='Health',
       critical_count=1,
       critical_insurers=[MockInsurer()],
       company_name='Marsh Brasil',
       timestamp='04/02/2026 as 10:00'
   )
   print('Template renders:', len(html) > 0)
   "
   ```
</verification>

<success_criteria>
- alert_critical.html template exists with Portuguese content
- CriticalAlertService.find_critical_insurers() finds Critical status insurers
- CriticalAlertService.check_and_send_alert() sends alert email with [CRITICAL ALERT] subject
- Run model updated with critical_alert_sent tracking
- Alert email is separate workflow from daily digest
</success_criteria>

<output>
After completion, create `.planning/phases/06-delivery-critical-alerts/06-04-SUMMARY.md`
</output>
