---
phase: 01-foundation-data-layer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/main.py
  - app/database.py
  - app/dependencies.py
  - app/models/__init__.py
  - app/models/insurer.py
  - app/schemas/__init__.py
  - app/schemas/insurer.py
  - requirements.txt
  - .env.example
autonomous: true
user_setup: []

must_haves:
  truths:
    - "FastAPI application starts without errors"
    - "Database connection is established"
    - "Insurer model creates table in SQLite"
    - "Health check endpoint responds"
  artifacts:
    - path: "app/main.py"
      provides: "FastAPI application entry point"
      exports: ["app"]
    - path: "app/database.py"
      provides: "SQLAlchemy engine and session configuration"
      exports: ["engine", "SessionLocal", "Base"]
    - path: "app/models/insurer.py"
      provides: "Insurer ORM model"
      contains: "class Insurer"
    - path: "app/schemas/insurer.py"
      provides: "Pydantic validation schemas"
      exports: ["InsurerBase", "InsurerCreate", "InsurerUpdate", "InsurerResponse"]
  key_links:
    - from: "app/main.py"
      to: "app/database.py"
      via: "Base.metadata.create_all on startup"
      pattern: "Base\\.metadata\\.create_all"
    - from: "app/dependencies.py"
      to: "app/database.py"
      via: "SessionLocal import"
      pattern: "from.*database.*import.*SessionLocal"
---

<objective>
Set up FastAPI project structure with SQLite database, Insurer ORM model, and Pydantic schemas.

Purpose: Establish the foundational architecture that all subsequent plans will build upon - database connectivity, model definitions, and validation schemas.

Output: Working FastAPI application with database initialization and health check endpoint.
</objective>

<execution_context>
@C:\Users\taylo\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\taylo\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@C:\BrasilIntel\.planning\PROJECT.md
@C:\BrasilIntel\.planning\ROADMAP.md
@C:\BrasilIntel\.planning\phases\01-foundation-data-layer\01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create project structure and dependencies</name>
  <files>
    requirements.txt
    .env.example
    app/__init__.py
    app/models/__init__.py
    app/schemas/__init__.py
    app/routers/__init__.py
    app/services/__init__.py
  </files>
  <action>
    Create requirements.txt with exact versions:
    - fastapi[standard]>=0.115.0
    - sqlalchemy>=2.0.0
    - pydantic>=2.0.0
    - pandas>=2.0.0
    - openpyxl>=3.1.0
    - python-dotenv>=1.0.0
    - uvicorn[standard]>=0.30.0

    Create .env.example with:
    - DATABASE_URL=sqlite:///./data/brasilintel.db
    - HOST=0.0.0.0
    - PORT=8000
    - DEBUG=true

    Create empty __init__.py files in app/, app/models/, app/schemas/, app/routers/, app/services/ directories.
  </action>
  <verify>
    - File exists: requirements.txt
    - File exists: .env.example
    - All __init__.py files exist in package directories
  </verify>
  <done>Project structure created with all package directories and dependency file ready for pip install</done>
</task>

<task type="auto">
  <name>Task 2: Create database configuration with SQLite</name>
  <files>
    app/database.py
    app/dependencies.py
  </files>
  <action>
    Create app/database.py following Pattern 1 from research:

    1. Import create_engine, sessionmaker, declarative_base from sqlalchemy
    2. Read DATABASE_URL from environment with default "sqlite:///./data/brasilintel.db"
    3. Create engine with CRITICAL SQLite settings:
       - connect_args={"check_same_thread": False} (required for FastAPI)
       - For sqlite, use autocommit=False connection arg for Python 3.12+
    4. Create SessionLocal with autocommit=False, autoflush=False
    5. Create Base using declarative_base()

    Create app/dependencies.py:
    1. Import SessionLocal from database
    2. Create get_db() generator function that:
       - Creates db = SessionLocal()
       - Yields db
       - Closes db in finally block
       - Does NOT commit (commit happens in endpoints per research Pattern 4 warning)
  </action>
  <verify>
    - app/database.py imports correctly: `python -c "from app.database import engine, SessionLocal, Base"`
    - app/dependencies.py imports correctly: `python -c "from app.dependencies import get_db"`
  </verify>
  <done>Database configuration established with proper SQLite settings and session dependency</done>
</task>

<task type="auto">
  <name>Task 3: Create Insurer model and Pydantic schemas</name>
  <files>
    app/models/insurer.py
    app/schemas/insurer.py
  </files>
  <action>
    Create app/models/insurer.py with SQLAlchemy ORM model:
    - __tablename__ = "insurers"
    - id: Integer, primary_key, autoincrement
    - ans_code: String(6), unique, not null, indexed (critical for lookups)
    - name: String(255), not null, indexed (for search)
    - cnpj: String(18), nullable
    - category: String(50), not null (Health, Dental, Group Life)
    - market_master: String(255), nullable
    - status: String(50), nullable
    - enabled: Boolean, default=True, not null
    - search_terms: String(500), nullable (for custom search terms per DATA-03)
    - created_at: DateTime, default=utcnow
    - updated_at: DateTime, onupdate=utcnow
    - Add UniqueConstraint on ans_code with name 'uix_ans_code'

    Create app/schemas/insurer.py with Pydantic v2 schemas:

    1. InsurerBase - shared fields with validation:
       - ans_code: str with Field(..., min_length=6, max_length=6, pattern=r'^\d{6}$')
       - name: str with Field(..., min_length=1, max_length=255)
       - cnpj: str | None = None
       - category: str with Field(..., pattern=r'^(Health|Dental|Group Life)$')
       - market_master: str | None = None
       - status: str | None = None
       - search_terms: str | None = None

    2. InsurerCreate(InsurerBase):
       - enabled: bool = True

    3. InsurerUpdate(BaseModel) - all optional for PATCH:
       - name: str | None = None
       - enabled: bool | None = None
       - search_terms: str | None = None

    4. InsurerResponse(InsurerBase):
       - id: int
       - enabled: bool
       - created_at: datetime | None
       - updated_at: datetime | None
       - model_config = ConfigDict(from_attributes=True) (Pydantic v2 syntax!)
  </action>
  <verify>
    - Model imports: `python -c "from app.models.insurer import Insurer; print(Insurer.__tablename__)"`
    - Schema validation works: `python -c "from app.schemas.insurer import InsurerCreate; InsurerCreate(ans_code='123456', name='Test', category='Health')"`
    - Schema rejects invalid: `python -c "from app.schemas.insurer import InsurerCreate; InsurerCreate(ans_code='12345', name='Test', category='Health')" 2>&1 | grep -i "error"` (should show validation error for short ans_code)
  </verify>
  <done>Insurer ORM model and Pydantic schemas created with proper v2 syntax and validation rules</done>
</task>

<task type="auto">
  <name>Task 4: Create FastAPI application with health check</name>
  <files>
    app/main.py
  </files>
  <action>
    Create app/main.py:

    1. Import FastAPI, load dotenv
    2. Import Base and engine from database
    3. Create FastAPI app with:
       - title="BrasilIntel API"
       - description="Competitive intelligence for Brazilian insurers"
       - version="0.1.0"

    4. Add startup event handler to create tables:
       @app.on_event("startup")
       def startup():
           # Create data directory if not exists
           os.makedirs("data", exist_ok=True)
           Base.metadata.create_all(bind=engine)

    5. Add health check endpoint:
       @app.get("/api/health")
       def health_check():
           return {"status": "healthy", "service": "brasilintel"}

    6. Add root redirect to docs:
       @app.get("/")
       def root():
           return {"message": "BrasilIntel API", "docs": "/docs"}
  </action>
  <verify>
    Run application and test:
    1. Start: `cd C:\BrasilIntel && python -m uvicorn app.main:app --host 0.0.0.0 --port 8000 &`
    2. Test health: `curl http://localhost:8000/api/health` should return {"status": "healthy", ...}
    3. Test docs: Visit http://localhost:8000/docs should show OpenAPI UI
    4. Verify database file created: `ls data/brasilintel.db`
  </verify>
  <done>FastAPI application starts, creates database on startup, and health check endpoint responds with status</done>
</task>

</tasks>

<verification>
1. Application starts without errors: `python -m uvicorn app.main:app`
2. Health endpoint responds: `curl http://localhost:8000/api/health`
3. Database file exists: `data/brasilintel.db`
4. OpenAPI docs available: `/docs` endpoint renders
5. All imports resolve without errors
</verification>

<success_criteria>
- FastAPI application starts and runs
- SQLite database file is created in data/ directory
- Health check endpoint returns {"status": "healthy"}
- Insurer table exists in database (verified via sqlite3 .tables)
- All Pydantic schemas validate correctly
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-data-layer/01-01-SUMMARY.md`
</output>
