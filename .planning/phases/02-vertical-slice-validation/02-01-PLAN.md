---
phase: 02-vertical-slice-validation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/models/news_item.py
  - app/models/run.py
  - app/models/__init__.py
  - app/schemas/news.py
  - app/schemas/run.py
  - app/schemas/__init__.py
  - app/main.py
autonomous: true

must_haves:
  truths:
    - "NewsItem model stores scraped news with title, URL, source, and classification fields"
    - "Run model tracks scraping runs with status, timing, and counts"
    - "Database tables created on application startup"
  artifacts:
    - path: "app/models/news_item.py"
      provides: "NewsItem ORM model with foreign keys to Run and Insurer"
      min_lines: 30
    - path: "app/models/run.py"
      provides: "Run ORM model with status tracking and timestamps"
      min_lines: 25
    - path: "app/schemas/news.py"
      provides: "Pydantic schemas for news items"
      exports: ["NewsItemCreate", "NewsItemRead", "NewsItemWithClassification"]
    - path: "app/schemas/run.py"
      provides: "Pydantic schemas for run tracking"
      exports: ["RunCreate", "RunRead", "RunStatus"]
  key_links:
    - from: "app/models/news_item.py"
      to: "app/models/insurer.py"
      via: "ForeignKey relationship"
      pattern: "ForeignKey.*insurers.id"
    - from: "app/models/news_item.py"
      to: "app/models/run.py"
      via: "ForeignKey relationship"
      pattern: "ForeignKey.*runs.id"
    - from: "app/main.py"
      to: "app/models/news_item.py"
      via: "import for table creation"
      pattern: "from app.models import.*news_item"
---

<objective>
Create database models for news items and run tracking to support the vertical slice pipeline.

Purpose: NewsItem and Run models form the persistence layer for scraped news and processing history, enabling end-to-end traceability from scraping through classification to reporting.

Output: ORM models and Pydantic schemas ready for use by scraper, classifier, and report services.
</objective>

<execution_context>
@C:\Users\taylo\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\taylo\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-vertical-slice-validation/02-RESEARCH.md

# Existing models to reference
@app/models/insurer.py
@app/database.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Run model for tracking scraping runs</name>
  <files>app/models/run.py, app/models/__init__.py</files>
  <action>
Create Run ORM model based on research pattern:

```python
# app/models/run.py
from sqlalchemy import Column, Integer, String, DateTime, Text
from sqlalchemy.orm import relationship
from app.database import Base
from datetime import datetime

class Run(Base):
    """Tracks individual scraping/classification runs."""
    __tablename__ = "runs"

    id = Column(Integer, primary_key=True, autoincrement=True)
    category = Column(String(50), nullable=False)  # Health, Dental, Group Life
    trigger_type = Column(String(20), nullable=False)  # scheduled, manual
    status = Column(String(20), default="pending")  # pending, running, completed, failed

    started_at = Column(DateTime, default=datetime.utcnow)
    completed_at = Column(DateTime, nullable=True)

    insurers_processed = Column(Integer, default=0)
    items_found = Column(Integer, default=0)
    error_message = Column(Text, nullable=True)

    # Relationships
    news_items = relationship("NewsItem", back_populates="run")
```

Update app/models/__init__.py to export Run:
```python
from app.models.insurer import Insurer
from app.models.run import Run
```
  </action>
  <verify>Python syntax check: `python -c "from app.models.run import Run; print('Run model OK')"`</verify>
  <done>Run model exists with all required fields (category, trigger_type, status, timestamps, counts)</done>
</task>

<task type="auto">
  <name>Task 2: Create NewsItem model with foreign keys</name>
  <files>app/models/news_item.py, app/models/__init__.py, app/models/insurer.py</files>
  <action>
Create NewsItem ORM model based on research pattern:

```python
# app/models/news_item.py
from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, Text
from sqlalchemy.orm import relationship
from app.database import Base
from datetime import datetime

class NewsItem(Base):
    """News item found during a scraping run."""
    __tablename__ = "news_items"

    id = Column(Integer, primary_key=True, autoincrement=True)
    run_id = Column(Integer, ForeignKey("runs.id"), nullable=False)
    insurer_id = Column(Integer, ForeignKey("insurers.id"), nullable=False)

    # News content
    title = Column(String(500), nullable=False)
    description = Column(Text, nullable=True)
    source_url = Column(String(1000), nullable=True)
    source_name = Column(String(255), nullable=True)
    published_at = Column(DateTime, nullable=True)

    # Classification results (populated by Azure OpenAI)
    status = Column(String(50), nullable=True)  # Critical, Watch, Monitor, Stable
    sentiment = Column(String(20), nullable=True)  # positive, negative, neutral
    summary = Column(Text, nullable=True)  # Bullet-point summary as JSON or newline-separated

    created_at = Column(DateTime, default=datetime.utcnow)

    # Relationships
    insurer = relationship("Insurer", back_populates="news_items")
    run = relationship("Run", back_populates="news_items")
```

Update app/models/insurer.py to add back_populates relationship:
```python
# Add to Insurer class
news_items = relationship("NewsItem", back_populates="insurer")
```

Update app/models/__init__.py:
```python
from app.models.insurer import Insurer
from app.models.run import Run
from app.models.news_item import NewsItem
```
  </action>
  <verify>Python syntax check: `python -c "from app.models.news_item import NewsItem; print('NewsItem model OK')"`</verify>
  <done>NewsItem model exists with foreign keys to Run and Insurer, classification fields present</done>
</task>

<task type="auto">
  <name>Task 3: Create Pydantic schemas for Run and NewsItem</name>
  <files>app/schemas/run.py, app/schemas/news.py, app/schemas/__init__.py</files>
  <action>
Create Pydantic schemas for API responses:

```python
# app/schemas/run.py
from pydantic import BaseModel, ConfigDict
from datetime import datetime
from typing import Optional
from enum import Enum

class RunStatus(str, Enum):
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"

class TriggerType(str, Enum):
    SCHEDULED = "scheduled"
    MANUAL = "manual"

class RunBase(BaseModel):
    category: str
    trigger_type: TriggerType = TriggerType.MANUAL

class RunCreate(RunBase):
    pass

class RunRead(RunBase):
    model_config = ConfigDict(from_attributes=True)

    id: int
    status: RunStatus
    started_at: datetime
    completed_at: Optional[datetime] = None
    insurers_processed: int
    items_found: int
    error_message: Optional[str] = None
```

```python
# app/schemas/news.py
from pydantic import BaseModel, ConfigDict
from datetime import datetime
from typing import Optional, List
from enum import Enum

class InsurerStatus(str, Enum):
    CRITICAL = "Critical"
    WATCH = "Watch"
    MONITOR = "Monitor"
    STABLE = "Stable"

class Sentiment(str, Enum):
    POSITIVE = "positive"
    NEGATIVE = "negative"
    NEUTRAL = "neutral"

class NewsItemBase(BaseModel):
    title: str
    description: Optional[str] = None
    source_url: Optional[str] = None
    source_name: Optional[str] = None
    published_at: Optional[datetime] = None

class NewsItemCreate(NewsItemBase):
    run_id: int
    insurer_id: int

class NewsItemRead(NewsItemBase):
    model_config = ConfigDict(from_attributes=True)

    id: int
    run_id: int
    insurer_id: int
    created_at: datetime

class NewsItemWithClassification(NewsItemRead):
    status: Optional[InsurerStatus] = None
    sentiment: Optional[Sentiment] = None
    summary: Optional[str] = None
```

Update app/schemas/__init__.py to export new schemas.
  </action>
  <verify>Python syntax check: `python -c "from app.schemas.run import RunCreate, RunRead; from app.schemas.news import NewsItemCreate; print('Schemas OK')"`</verify>
  <done>Pydantic schemas exist for Run and NewsItem with proper enums and validation</done>
</task>

</tasks>

<verification>
1. All models import without error: `python -c "from app.models import Insurer, Run, NewsItem"`
2. All schemas import without error: `python -c "from app.schemas.run import *; from app.schemas.news import *"`
3. Database tables can be created: Start server and verify tables exist in SQLite
4. Relationships work: Query insurer.news_items, news_item.insurer, news_item.run
</verification>

<success_criteria>
- Run model has fields: id, category, trigger_type, status, started_at, completed_at, insurers_processed, items_found, error_message
- NewsItem model has fields: id, run_id, insurer_id, title, description, source_url, source_name, published_at, status, sentiment, summary, created_at
- Foreign key relationships work bidirectionally (Insurer.news_items, NewsItem.insurer)
- Pydantic schemas validate and serialize correctly
- Server starts and creates new tables (runs, news_items)
</success_criteria>

<output>
After completion, create `.planning/phases/02-vertical-slice-validation/02-01-SUMMARY.md`
</output>
