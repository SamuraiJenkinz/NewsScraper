---
phase: 02-vertical-slice-validation
plan: 05
type: execute
wave: 2
depends_on: [02-02]
files_modified:
  - app/services/emailer.py
autonomous: true

must_haves:
  truths:
    - "Service sends HTML email via Microsoft Graph API"
    - "Daemon authentication uses ClientSecretCredential (no user interaction)"
    - "TO, CC, BCC recipients supported"
  artifacts:
    - path: "app/services/emailer.py"
      provides: "GraphEmailService for sending reports via Microsoft Graph"
      exports: ["GraphEmailService"]
      min_lines: 80
  key_links:
    - from: "app/services/emailer.py"
      to: "app/config.py"
      via: "get_settings() for Azure AD credentials"
      pattern: "get_settings\\(\\)"
---

<objective>
Create Microsoft Graph email service for sending HTML reports.

Purpose: Enables automated report delivery via corporate Exchange Online using Azure AD app authentication (daemon/service pattern).

Output: GraphEmailService class that sends HTML emails with TO/CC/BCC support.
</objective>

<execution_context>
@C:\Users\taylo\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\taylo\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-vertical-slice-validation/02-RESEARCH.md

# Dependencies
@app/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GraphEmailService class</name>
  <files>app/services/emailer.py</files>
  <action>
Create Microsoft Graph email service based on research pattern:

```python
# app/services/emailer.py
"""
Microsoft Graph email service for sending HTML reports.

Uses daemon authentication (ClientSecretCredential) for automated
email sending without user interaction. Requires Mail.Send application
permission with admin consent in Azure AD.
"""
import logging
from typing import Any

from azure.identity import ClientSecretCredential
from msgraph import GraphServiceClient
from msgraph.generated.users.item.send_mail.send_mail_post_request_body import (
    SendMailPostRequestBody,
)
from msgraph.generated.models.message import Message
from msgraph.generated.models.item_body import ItemBody
from msgraph.generated.models.body_type import BodyType
from msgraph.generated.models.recipient import Recipient
from msgraph.generated.models.email_address import EmailAddress

from app.config import get_settings

logger = logging.getLogger(__name__)


class GraphEmailService:
    """
    Service for sending HTML emails via Microsoft Graph API.

    Uses Azure AD app registration with Mail.Send application permission
    for daemon (service-to-service) authentication.

    Prerequisites:
    1. Azure AD app registration with Mail.Send application permission
    2. Admin consent granted for the permission
    3. Sender email must be a valid mailbox the app has access to
    """

    def __init__(self):
        settings = get_settings()

        if not settings.is_graph_configured():
            logger.warning("Microsoft Graph not configured - email will fail")
            self.client = None
            self.sender_email = None
        else:
            # Daemon app authentication (no user interaction)
            credential = ClientSecretCredential(
                tenant_id=settings.azure_tenant_id,
                client_id=settings.azure_client_id,
                client_secret=settings.azure_client_secret,
            )
            self.client = GraphServiceClient(credential)
            self.sender_email = settings.sender_email

    async def send_email(
        self,
        to_addresses: list[str],
        subject: str,
        html_body: str,
        cc_addresses: list[str] | None = None,
        bcc_addresses: list[str] | None = None,
        save_to_sent: bool = True,
    ) -> dict[str, Any]:
        """
        Send an HTML email via Microsoft Graph.

        Args:
            to_addresses: List of TO recipient email addresses
            subject: Email subject line
            html_body: HTML content for email body
            cc_addresses: Optional list of CC recipients
            bcc_addresses: Optional list of BCC recipients
            save_to_sent: Whether to save email to Sent folder

        Returns:
            dict with status and any error message
        """
        if not self.client:
            logger.error("Graph client not initialized - check Azure credentials")
            return {"status": "error", "message": "Microsoft Graph not configured"}

        if not to_addresses:
            return {"status": "error", "message": "No recipients specified"}

        try:
            # Build message
            message = Message(
                subject=subject,
                body=ItemBody(
                    content_type=BodyType.Html,
                    content=html_body,
                ),
                to_recipients=[
                    Recipient(email_address=EmailAddress(address=addr))
                    for addr in to_addresses
                ],
            )

            # Add CC recipients if provided
            if cc_addresses:
                message.cc_recipients = [
                    Recipient(email_address=EmailAddress(address=addr))
                    for addr in cc_addresses
                ]

            # Add BCC recipients if provided
            if bcc_addresses:
                message.bcc_recipients = [
                    Recipient(email_address=EmailAddress(address=addr))
                    for addr in bcc_addresses
                ]

            # Build request body
            request_body = SendMailPostRequestBody(
                message=message,
                save_to_sent_items=save_to_sent,
            )

            # Send from configured sender
            logger.info(f"Sending email to {len(to_addresses)} recipients: {subject}")
            await self.client.users.by_user_id(self.sender_email).send_mail.post(
                request_body
            )

            logger.info("Email sent successfully")
            return {
                "status": "ok",
                "recipients": len(to_addresses),
                "cc": len(cc_addresses) if cc_addresses else 0,
                "bcc": len(bcc_addresses) if bcc_addresses else 0,
            }

        except Exception as e:
            logger.error(f"Failed to send email: {e}")
            return {"status": "error", "message": str(e)}

    async def send_report_email(
        self,
        category: str,
        html_content: str,
        report_date: str,
    ) -> dict[str, Any]:
        """
        Send a report email for a specific category.

        Uses recipient list from configuration for the category.

        Args:
            category: Report category (Health, Dental, Group Life)
            html_content: Rendered HTML report content
            report_date: Report date string for subject line

        Returns:
            dict with status and any error message
        """
        settings = get_settings()
        recipients = settings.get_report_recipients(category)

        if not recipients:
            logger.warning(f"No recipients configured for {category} reports")
            return {
                "status": "skipped",
                "message": f"No recipients configured for {category}",
            }

        subject = f"[{settings.company_name}] {category} Intelligence Report - {report_date}"

        return await self.send_email(
            to_addresses=recipients,
            subject=subject,
            html_body=html_content,
        )

    def health_check(self) -> dict[str, Any]:
        """
        Check Microsoft Graph service connectivity.

        Note: This is a synchronous check of configuration only.
        Full connectivity test would require async context.

        Returns dict with status and any error message.
        """
        if not self.client:
            return {"status": "error", "message": "Microsoft Graph not configured"}

        if not self.sender_email:
            return {"status": "error", "message": "Sender email not configured"}

        # We can't do a full test without async, so just check config
        return {
            "status": "configured",
            "sender": self.sender_email,
            "note": "Full test requires async context",
        }

    async def health_check_async(self) -> dict[str, Any]:
        """
        Async health check with actual Graph API test.

        Returns dict with status and any error message.
        """
        if not self.client:
            return {"status": "error", "message": "Microsoft Graph not configured"}

        try:
            # Try to get user info as connectivity test
            user = await self.client.users.by_user_id(self.sender_email).get()
            return {
                "status": "ok",
                "sender": self.sender_email,
                "display_name": user.display_name if user else None,
            }
        except Exception as e:
            return {"status": "error", "message": str(e)}
```
  </action>
  <verify>python -c "from app.services.emailer import GraphEmailService; s = GraphEmailService(); print(s.health_check())"</verify>
  <done>GraphEmailService created with send_email, send_report_email, and health checks</done>
</task>

<task type="auto">
  <name>Task 2: Update services __init__.py</name>
  <files>app/services/__init__.py</files>
  <action>
Export the email service:

```python
# app/services/__init__.py
from app.services.excel_service import parse_excel_upload, generate_excel_export
from app.services.scraper import ApifyScraperService
from app.services.classifier import ClassificationService
from app.services.emailer import GraphEmailService
```
  </action>
  <verify>python -c "from app.services import GraphEmailService; print('Export OK')"</verify>
  <done>GraphEmailService exported from services package</done>
</task>

</tasks>

<verification>
1. Service imports: `python -c "from app.services.emailer import GraphEmailService"`
2. Instance creates without error: `python -c "from app.services.emailer import GraphEmailService; s = GraphEmailService(); print(s.health_check())"`
3. Config integration: Service reads Azure credentials from Settings
4. Health check returns appropriate status based on configuration
</verification>

<success_criteria>
- GraphEmailService uses ClientSecretCredential for daemon auth
- send_email() accepts to_addresses, subject, html_body, cc_addresses, bcc_addresses
- send_report_email() uses category-specific recipients from config
- Graceful error handling when credentials missing or API fails
- health_check() and health_check_async() return service status
- All methods return dict with status field
</success_criteria>

<output>
After completion, create `.planning/phases/02-vertical-slice-validation/02-05-SUMMARY.md`
</output>
